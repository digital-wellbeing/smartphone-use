# Descriptives and Visualizations

## Overview

In this section, I describe and visualize the sample and variables.
We have variables on the meta-level (about the survey), the person-level, the app-level, and the day-level.
App-level data is in the `apps_long` data file; all other in the `dat` data file.

**Meta-level**

* Duration of the entry survey, when participants reported traits (`duration_personality`)
* Duration of the exit survey, when participants reported their screen time (`duration_screen_time`)

**Person-level**

* Participant identifier (`id`)
* `age` in years
* `ethnicity`
* Notifications of social media apps over the past week (`weekly_notifications`)
* Basic Psychological Need Satisfaction (`autonomy_trait`, `competence_trait`, `relatedness_trait`) plus their individual items (starting with `bpns_`)
* Big Five (`extraversion`, `agreeableness`, `conscientiousness`, `neuroticsim`, `openness`) plus their individual items (starting with `big_five_`)

**App-level**

* What app participants report use for (`app`)
* On what rank was that app on participants' top ten (`rank`)
* Notifications for that app for the week (`notifications_per_week`)
* Pickups for that app on that day (`pickups`)
* Screen time for that app on that day (`social_media_objective`)

**Day-level**

* Duration of the survey on that day (`duration_diary`)
* `day` the survey was answered
* Estimated time on social media on that day (`social_media_subjective`)
* Estimated pickups of social media apps on that day (`pickups_subjective`)
* Estimated notifications of social media apps on that day (`notifications_subjective`)
* Objective time on social media on that day (`social_media_objective`)
* Objective pickups of social media apps on that day (`pickups_objective`)
* Well-being on that day (`well_being`) plus its individual items (starting with `low_` and `high_`)
* Basic psychological needs on that day (`autonomy_state`, `competence_state`, `relatedness_state`) plus their individual items (starting with `autonomy_`, `competence_`, `relatedness_` respectively)
* Experiences of satisfaction, boredom, stress, enjoyment on that day (`satisfied`, `boring`, `stressful`, `enoyable`)

## Meta-level

I begin with describing and plotting the duration of the entry and exit surveys.
Table \@ref(tab:describe-durations) shows descriptive stats; Figure \@ref(fig:visualize-durations) shows that twp participants had their entry surveys open for a day before pressing send, which skews the mean massively.
However, those people's data look good, so I wouldn't exclude them here.
Note: Colors are from [here](https://www.datanovia.com/en/blog/ggplot-colors-best-tricks-you-will-love/#use-a-colorblind-friendly-palette).
```{r describe-durations, echo=FALSE}
# get the descriptives and bind them into a data frame (see custom functions)
durations <- 
  bind_rows(
    list(
      describe(
        dat,
        "duration_personality",
        trait = TRUE
      ),
      describe(
        dat,
        "duration_screen_time",
        trait = TRUE
      )
    )
  )

# round seconds and then transform into time
durations <-  
  durations %>% 
  mutate(
    across(
      -variable,
      round
    )
  ) %>% 
  mutate_at( #note: I didn't get this to go with across()
    vars(-variable),
    list(~seconds_to_period(.))
  )

knitr::kable(
  durations,
  caption = "Duration of entry and exit surveys"
)
```

```{r visualize-durations, fig.cap= "Duration of surveys", echo=FALSE}
plot_grid(
  single_cloud( # custom function, see setting up chapter
    dat,
    durations,
    "duration_personality",
    "#009E73",
    title = "Density of duration of entry survey (in s)",
    trait = TRUE
  ),
  single_cloud(
    dat,
    durations,
    "duration_screen_time",
    "#D55E00",
    title = "Density of duration of exit survey (in s)",
    trait = TRUE
  ),
  ncol = 1
)
```

## Person-level

Let's have a look at the final sample.
Overall, our sample size is **N = `r dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% nrow()`**.
The sample has a mean age of *M* = `r round(dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% pull(age) %>% mean(), digits = 2)`, *SD* = `r round(dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% pull(age) %>% sd(), digits = 2)`.
The sample consists mostly of women (`r dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% filter(gender == "female") %>% nrow()` women, `r dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% filter(gender == "male") %>% nrow()` men, and one non-binary participant).
```{r describe-age, echo=FALSE}
age <- 
  describe(
    dat,
    "age",
    trait = TRUE
  )
```
```{r visualize-age, echo=FALSE}
single_cloud(
  dat,
  age,
  "age",
  "#009E73",
  title = NULL,
  trait = TRUE
)
```

Most participants are Asian, followed by White, Black, and Hispanic, see Table \@ref(tab:ethnicity-table)
```{r ethnicity-table, echo = FALSE}
dat %>% 
  group_by(id) %>% 
  slice(1) %>% 
  ungroup() %>% 
  count(ethnicity) %>% 
  rename(count = n) %>% 
  mutate(percent = 100 * round(count / sum(count), digits = 2)) %>% 
  arrange(desc(percent)) %>% 
  knitr::kable(
    .,
    caption = "Ethnicity of the sample"
  )
```

Alright, next we look at the objective count of notifications over the past week, aggregated across all apps.
Table \@ref(tab:weekly-notifications-table) shows that participants received quite a lot of notifications from social media apps only.
That distribution is heavily skewed (Figure \@ref(fig:visualize-weekly-notifications) by a couple of participants who received several thousand notifications over the week.
```{r weekly-notifications-table, echo=FALSE}
notifications <- 
  describe(
    dat,
    "weekly_notifications",
    trait = TRUE
  )

notifications %>% 
  knitr::kable(
    .,
    caption = "Weekly notifications (objective) across all apps"
  )
```

```{r visualize-weekly-notifications, echo=FALSE, fig.cap="Weekly notifications (objective) across all apps"}
single_cloud(
  dat,
  notifications,
  "weekly_notifications",
  "#009E73",
  title = NULL,
  trait = TRUE
)
```

Now we look at the trait variables: the basic psychological need satisfaction and the big five.
Note that I follow recent recommendations and calculate $\omega$ for reliability.
Table \@ref(tab:traits-descriptives) shows the descriptive information of the three psychological needs and the big five.
Figure \@ref(fig:traits-visualize) shows their distribution.
The sample isn't too large, so considering the small size, I'd say everything looks pretty good.
```{r traits-descriptives, echo=FALSE}
### descriptives for BPNS
bpns <- 
  bind_rows(
    list(
      describe(
        dat,
        "autonomy_trait",
        trait = TRUE
      ),
      describe(
        dat,
        "competence_trait",
        trait = TRUE
      ),
      describe(
        dat,
        "relatedness_trait",
        trait = TRUE
      )
    )
  )

# get omega with the MBESS package
autonomy_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(bpns_1:bpns_8),
    type = "omega",
    B = 1e4
  )$est

competence_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(bpns_9:bpns_16),
    type = "omega",
    B = 1e4
  )$est

competence_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(bpns_9:bpns_16),
    type = "omega",
    B = 1e4
  )$est

relatedness_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(bpns_17:bpns_24),
    type = "omega",
    B = 1e4
  )$est

# add omega to scales
bpns <- 
  bpns %>% 
  mutate(
    omega = c(autonomy_omega, competence_omega, relatedness_omega)
  )

### Descriptives for big five
big_five <- 
  bind_rows(
    list(
      describe(
        dat,
        "extraversion",
        trait = TRUE
      ),
      describe(
        dat,
        "agreeableness",
        trait = TRUE
      ),
      describe(
        dat,
        "conscientiousness",
        trait = TRUE
      ),
      describe(
        dat,
        "neuroticism",
        trait = TRUE
      ),
      describe(
        dat,
        "openness",
        trait = TRUE
      )
    )
  )

# get omegas
extraversion_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(
        big_five_1,
        big_five_6,
        big_five_11,
        big_five_16,
        big_five_21,
        big_five_26,
        big_five_31,
        big_five_36
      ),
    type = "omega",
    B = 1e4
  )$est

agreeableness_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(
        big_five_2,
        big_five_7,
        big_five_12,
        big_five_17,
        big_five_22,
        big_five_27,
        big_five_32,
        big_five_37,
        big_five_42
      ),
    type = "omega",
    B = 1e4
  )$est

conscientiousness_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(
        big_five_3,
        big_five_8,
        big_five_13,
        big_five_18,
        big_five_23,
        big_five_28,
        big_five_33,
        big_five_38,
        big_five_43
      ),
    type = "omega",
    B = 1e4
  )$est

neuroticism_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(
        big_five_4,
        big_five_9,
        big_five_14,
        big_five_19,
        big_five_24,
        big_five_29,
        big_five_34,
        big_five_39
      ),
    type = "omega",
    B = 1e4
  )$est

openness_omega <- 
  ci.reliability(
    data = dat %>% 
      group_by(id) %>% 
      slice(1) %>% 
      ungroup() %>% 
      select(
        big_five_5,
        big_five_10,
        big_five_15,
        big_five_20,
        big_five_25,
        big_five_30,
        big_five_35,
        big_five_40,
        big_five_41,
        big_five_44
      ),
    type = "omega",
    B = 1e4
  )$est

# add omegas to descriptives
big_five <- 
  big_five %>% 
  mutate(
    omega = c(
      extraversion_omega,
      agreeableness_omega,
      conscientiousness_omega,
      neuroticism_omega,
      openness_omega
    )
  )

# bind those two and round to two decimals
trait_descriptives <- 
  bind_rows(
    bpns,
    big_five
  ) %>% 
  mutate(
    across(
      -variable,
      ~ round(.x, digits = 2)
    )
  )

knitr::kable(
  trait_descriptives,
  caption = "Descriptives for trait variables"
)

# clear up workspace
rm(
  bpns,
  autonomy_omega,
  competence_omega,
  relatedness_omega,
  big_five,
  extraversion_omega,
  agreeableness_omega,
  conscientiousness_omega,
  neuroticism_omega,
  openness_omega
)
```

```{r traits-visualize, fig.cap="Distribution of trait variables", fig.dim=c(8.5,9), echo=FALSE}
plot_grid(
  # bpns
  single_cloud(
    dat,
    trait_descriptives,
    "autonomy_trait",
    "#999999",
    title = "Autonomy",
    trait = TRUE
  ),
  single_cloud(
    dat,
    trait_descriptives,
    "competence_trait",
    "#E69F00",
    title = "Competence",
    trait = TRUE
  ),
  single_cloud(
    dat,
    trait_descriptives,
    "relatedness_trait",
    "#56B4E9",
    title = "Relatedness",
    trait = TRUE
  ),
  
  # big five
  single_cloud(
    dat,
    trait_descriptives,
    "extraversion",
    "#009E73",
    title = "Extraversion",
    trait = TRUE
  ),
  single_cloud(
    dat,
    trait_descriptives,
    "agreeableness",
    "#F0E442",
    title = "Agreeableness",
    trait = TRUE
  ),
  single_cloud(
    dat,
    trait_descriptives,
    "conscientiousness",
    "#0072B2",
    title = "Conscientiousness",
    trait = TRUE
  ),
  single_cloud(
    dat,
    trait_descriptives,
    "neuroticism",
    "#D55E00",
    title = "Neuroticism",
    trait = TRUE
  ),
  single_cloud(
    dat,
    trait_descriptives,
    "openness",
    "#CC79A7",
    title = "Openness",
    trait = TRUE
  ),
  ncol = 2
)
```

In Figure \@ref(fig:visualize-correlations-traits) we see the correlations between those traits.
As expected psychological needs are correlated highly with each other.
Credit for the `lm` lines goes to [data prone](https://www.r-bloggers.com/multiple-regression-lines-in-ggpairs/), whose idea I adapted.
```{r visualize-correlations-traits, fig.cap="Correlation matrix of trait level variables", fig.dim=c(12,12), echo=FALSE, message=FALSE}
ggpairs(
  data = dat %>%
    group_by(id) %>% 
    slice(1) %>% 
    ungroup() %>% 
    select(
      autonomy_trait:relatedness_trait,
      extraversion:openness
    ) %>% 
    rename_with(
      ~ str_remove(.x, "_trait"),
      autonomy_trait:relatedness_trait
    ),
  lower = list(
    continuous = lm_function # custom helper function
  ),
  diag = list(
    continuous = dens_function # custom helper function
  )
) +
  theme(
    axis.line=element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks=element_blank(),
    axis.title.y=element_blank(),
    axis.title.x=element_blank(),
    legend.position="none",
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

## App-level

First, Figure \@ref(fig:visualize-nominated-apps) shows what apps mostly nominated (i.e., used).
We see that out of the sample, most participants had Messaging, Snapchat, Whatsapp etc. as part of their top ten.
```{r visualize-nominated-apps, echo=FALSE, fig.cap="Percentage of nominated apps", fig.dim=c(11,11)}
apps_long %>%
  filter(day == "monday") %>% 
  mutate(
    app = str_to_lower(app)
  ) %>% 
  filter(!is.na(app)) %>% 
  count(app) %>% 
  mutate(percent = round((n / sum(n)), digits = 3) * 100) %>% 
  rename(
    count = n
  ) %>%
  ggplot(
    aes(
      reorder(x = app, percent),
      y = percent
    )
  ) +
  geom_point(size = 3, color = "#D55E00") +
  geom_segment(
    aes(
      x = app,
      xend = app,
      y = 0,
      yend = percent
    ),
    color = "#D55E00",
    alpha = 0.5
  ) + 
  coord_flip() +
  theme(
    axis.line=element_blank(),
    axis.ticks=element_blank(),
    axis.title.y=element_blank(),
    legend.position="none",
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

Next, I visualize how many minutes each of those apps was used across the sample.
For that, I need to reshape the data a bit to get the mean minutes per app across all days and all participants.
In Figure \@ref(fig:visualize-minutes-per-app), I show the average objective time per app.
Note that the CIs are across the entire data and not nested by app or day.
Also, a high mean doesn't mean that much because it could just be from one participant who used it a lot on two days.
The size of the points shows how often an app was reported across the entire sample.
For apps that only had one entry, those CI will be nonexistent.
In addition, I now exclude entries on `social_media_objective` that have `NA`.
The `NA` here can mean participants just didn't fill in anything, or they had zero duration on that day.
Because adding up the raw scores across apps was so close to the daily total, I'll exclude `NA`s here.
```{r visualize-minutes-per-app, echo=FALSE, warning=FALSE, message=FALSE, fig.cap="Average daily objective time for all apps across participants and days", fig.dim=c(12,10)}
apps_long %>%
  filter(!is.na(app)) %>%
  filter(!is.na(social_media_objective)) %>% 
  group_by(app) %>% 
  summarise(
    count = n(),
    time = mean(social_media_objective, na.rm = TRUE),
    ci_upper = Rmisc::CI(social_media_objective)[[1]],
    ci_lower = Rmisc::CI(social_media_objective)[[3]]
  ) %>% 
  ungroup() %>% 
  ggplot(
    .,
    aes(
      x =  reorder(x = app, time),
      y = time,
      color = app
    )
  ) +
  geom_point(
    aes(
      size = count
    )
  ) +
  geom_errorbar(
    aes(
      ymin = ci_lower,
      ymax = ci_upper
    ),
    width = 0
  ) +
  guides(
    color = FALSE
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x=element_blank(),
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

I'll do the same for objective pickups per app, averaged across day and participant.
Figure \@ref(fig:visualize-pickups-per-app) shows that the same apps that got a lot of screen time had a lot of pickups.
```{r visualize-pickups-per-app, echo=FALSE, warning=FALSE, message=FALSE, fig.cap="Average daily pickups for all apps across participants and days", fig.dim=c(12,10)}
apps_long %>%
  filter(!is.na(app)) %>% 
  filter(!is.na(pickups)) %>% 
  group_by(app) %>% 
  summarise(
    count = n(),
    mean_pickups = mean(pickups, na.rm = TRUE),
    ci_upper = Rmisc::CI(pickups)[[1]],
    ci_lower = Rmisc::CI(pickups)[[3]]
  ) %>%
  ungroup() %>% 
  ggplot(
    .,
    aes(
      x =  reorder(x = app, mean_pickups),
      y = mean_pickups,
      color = app
    )
  ) +
  geom_point(
    aes(
      size = count
    )
  ) +
  geom_errorbar(
    aes(
      ymin = ci_lower,
      ymax = ci_upper
    ),
    width = 0
  ) +
  guides(
    color = FALSE
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x=element_blank(),
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

Last, I check which apps got the most notifications over the week in Figure \@ref(fig:visualize-notifications-per-app), on average.
It's interesting to see that Facebook had a lot of screen time and pickups, but much fewer notifications.
Also, these notifications are per week, and not per day, as the previous two figures.
```{r visualize-notifications-per-app, echo=FALSE, warning=FALSE, message=FALSE, fig.cap="Average notifications per week for all apps across participants", fig.dim=c(12,10)}
apps_long %>%
  filter(!is.na(app)) %>% 
  filter(!is.na(notifications_per_week)) %>% 
  group_by(app) %>% 
  summarise(
    count = n(),
    weekly_notifications = mean(notifications_per_week, na.rm = TRUE),
    ci_upper = Rmisc::CI(notifications_per_week)[[1]],
    ci_lower = Rmisc::CI(notifications_per_week)[[3]]
  ) %>%
  ungroup() %>% 
  ggplot(
    .,
    aes(
      x =  reorder(x = app, weekly_notifications),
      y = weekly_notifications,
      color = app
    )
  ) +
  geom_point(
    aes(
      size = count
    )
  ) +
  geom_errorbar(
    aes(
      ymin = ci_lower,
      ymax = ci_upper
    ),
    width = 0
  ) +
  guides(
    color = FALSE
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x=element_blank(),
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

## Day level

Alright, we're at the most interesting section, the daily surveys.
I first look at how long people typically took for a survey.
Table \@ref(tab:describe-survey-duration) shows that the mean is highly skewed because of outliers and the median more appropriate to describe the duration.
In Figure \@ref(fig:visualize-survey-duration) we see that a couple of people took a long time from opening to submitting the survey.
I checked those participants who took a long time in the [data processing section](#data-processing).
The maximum duration here from someone who didn't open the survey on a Friday.
So that duration is just the survey closing automatically after two days, which really drives up the mean.
```{r describe-survey-duration, echo=FALSE}
knitr::kable(
  describe(
    dat,
    "duration_diary"
  ) %>% 
    mutate(
      across(
        -variable,
        round
      )
    ) %>% 
    mutate_at(
      vars(-variable),
      list(~seconds_to_period(.))
    ),
  caption = "Duration of daily surveys"
)
```

```{r visualize-survey-duration, fig.cap= "Duration of daily surveys", echo=FALSE, warning=FALSE}
single_cloud(
  dat,
  describe(
    dat,
    "duration_diary"
  ),
  "duration_diary",
  color = "#009E73",
  title = NULL,
  trait = FALSE
)
```

Alright, next I inspect overall response rate in the final sample, aka how many valid surveys do we have among the final sample.
Each participant received five surveys, one for each day, so `r dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% nrow()` participants x 5 = `r dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% nrow() * 5`.
We have `r dat %>% filter(!is.na(enjoyable)) %>% nrow()` surveys in the final sample where participants actually responded, which means a `r round(dat %>% filter(!is.na(enjoyable)) %>% nrow() / (dat %>% group_by(id) %>% slice(1) %>% ungroup() %>% nrow() * 5) * 100)`% response rate among the final sample.

Let's inspect response rate per day.
As is to be expected, participants lost motivation over the course of the week.
However, even the response rate on Friday is really high (at least among our sample of valid responses).
We should still consider to take the day grouping into account when modelling the data later in the analysis.
```{r responses-per-day, echo=FALSE, fig.cap="Survey responses per day"}
dat %>% 
  filter(!is.na(enjoyable)) %>% # last item of the diary, so going for complete responses here
  count(day) %>% 
  mutate(percent = round(n / nrow(dat %>% group_by(id) %>% slice(1)) * 100)) %>%  # divide by maximum number of surveys, which is number of valid participants
  ggplot(
    aes(
      x = day,
      y = percent,
      color = day
    )
  ) +
  geom_segment(
    aes(
      x = day,
      xend = day,
      y = 0,
      yend = percent
    ),
    alpha = 0.5
  ) +
  geom_point(alpha = 0.5, size = 2) +
  scale_color_manual(values = c("#E69F00", "#56B4E9", "#009E73", "#D55E00", "#0072B2")) +
  geom_text(
    aes(
      label = percent,
      y = percent + 4
    )
  ) +
  theme(
    axis.title.x=element_blank(),
    legend.position = "none",
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

Next, I describe and plot the distributions of the social media use variables.
The distribution and CI is of the entire sample, not aggregated by participant or day first.
Table \@ref(tab:social-media-descriptives) shows that participants weren't too far off in their estimates, which is interesting.
As expected (Figure \@ref(fig:social-media-visualize)), the social media variables are a bit skewed, but overall, they look fine.
```{r social-media-descriptives, echo=FALSE}
### descriptives for BPNS
social_media <- 
  bind_rows(
    list(
      describe(
        dat,
        "social_media_subjective",
        trait = FALSE
      ),
      describe(
        dat,
        "social_media_objective",
        trait = FALSE
      ),
      describe(
        dat,
        "error",
        trait = FALSE
      ),
      describe(
        dat,
        "pickups_subjective",
        trait = FALSE
      ),
      describe(
        dat,
        "pickups_objective",
        trait = FALSE
      ),
      describe(
        dat,
        "notifications_subjective",
        trait = FALSE
      )
    )
  ) %>% 
  mutate(
    across(
      -variable,
      round
    )
  )

social_media %>% 
  knitr::kable(
    .,
    caption = "Descriptive information on social media variables"
  )
```

```{r social-media-visualize, warning=FALSE, message=FALSE, fig.cap="Distribution of social media variables", fig.dim=c(8.5,9), echo=FALSE}
plot_grid(
  # screen time
  single_cloud(
    dat,
    social_media,
    "social_media_subjective",
    "#999999",
    title = "Subjective screen time",
    trait = FALSE
  ),
  single_cloud(
    dat,
    social_media,
    "social_media_objective",
    "#E69F00",
    title = "Objective screen time",
    trait = FALSE
  ),
  single_cloud(
    dat,
    social_media,
    "error",
    "#CC79A7",
    title = "Percent error",
    trait = FALSE
  ),
  single_cloud(
    dat,
    social_media,
    "pickups_subjective",
    "#56B4E9",
    title = "Subjective pickups",
    trait = FALSE
  ),
  single_cloud(
    dat,
    social_media,
    "pickups_objective",
    "#009E73",
    title = "Objective pickups",
    trait = FALSE
  ),
  single_cloud(
    dat,
    social_media,
    "notifications_subjective",
    "#F0E442",
    title = "Subjective notifications",
    trait = FALSE
  ),
  ncol = 2
)
```

I also want to see how much variability there is between the objective and subjective measures.
In Figure \@ref(fig:dumbbell-social-media) we see per participant the difference between objective and subjective social media use.
The numbers in the grey box show whether the subjective report is an underestimate (negative number) or overestimate (positive number).
Inspiration for the plot from [here](https://rud.is/b/2016/04/17/ggplot2-exercising-with-ggalt-dumbbells/) and [here](https://stackoverflow.com/questions/44653597/adding-a-traditional-legend-to-dumbbell-plot-in-ggaltgeom-dumbbell-in-r).
```{r dumbbell-social-media, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Difference between subjective and objective social media use (difference in grey box)", fig.dim=c(8,20)}
# aggregate by participant over day
plot_data <- 
  dat %>% 
  group_by(id) %>% 
  summarise(
    social_media_objective = mean(social_media_objective, na.rm = T),
    social_media_subjective = mean(social_media_subjective, na.rm = T)
  ) %>% 
  ungroup() %>% 
  mutate(diff = round(social_media_subjective - social_media_objective),
         id = as.factor(parse_number(as.character(id)))) %>% 
  arrange(id)

# same as above, but in long format so we can get a legend
plot_data_long <- 
  dat %>% 
  group_by(id) %>% 
  summarise(
    social_media_objective = mean(social_media_objective, na.rm = T),
    social_media_subjective = mean(social_media_subjective, na.rm = T)
  ) %>% 
  ungroup() %>% 
  pivot_longer(
    cols = -id,
    names_to = "measure",
    names_prefix = "social_media_",
    values_to = "time"
  ) %>% 
  mutate(id = as.factor(parse_number(as.character(id)))) %>% 
  arrange(id)

# dumbbell plot
ggplot(
  plot_data,
  aes(
    y = id
  )
) +
  geom_dumbbell(
    aes(
      x = social_media_subjective,
      xend = social_media_objective
    ),
    size = 2,
    colour_x = "lightblue",
    colour_xend = "darkblue",
    color = "lightgrey"
  ) +
  geom_point(
    data = plot_data_long,
    aes(
      x = time,
      color = measure
    ),
    size = 5
  ) + 
  geom_rect(
    data = plot_data,
    aes(
      xmin = 530,
      xmax = 570,
      ymin = -Inf,
      ymax = Inf
    ),
    fill = "lightgrey"
  ) +
  # add difference
  geom_text(
    data = plot_data,
    aes(
      label = diff,
      y = id,
      x = 550
    )
  ) +
  labs(
    x = "Minutes",
    y = "Participant"
  ) +
  scale_color_manual(
    label = c("Objective", "Subjective"),
    name = "Legend",
    values = c("darkblue", "lightblue"))

# clear workspace
rm(
  plot_data,
  plot_data_long
)
```


Now let's look at the state well-being and psychological needs variables plus the four experiences (e.g., `boring`).
Again, I calculate $\omega$, but this time for the entire sample in Table \@ref(tab:states-descriptives).
That will necessarily bias the estimate because there's multiple measures per person.
I'm not aware of a consensus reliability procedure for repeated measures.
Figure \@ref(fig:states-visualize) shows that the data look pretty good.
```{r states-descriptives, echo=FALSE, message=FALSE, warning=FALSE}
### well-being
well_being <- 
  describe(
    dat,
    "well_being_state",
    trait = FALSE
  )

# get omega
well_being_omega <- 
  ci.reliability(
    data = dat %>% 
      select(low_positive_peaceful:low_negative_gloomy),
    type = "omega",
    B = 1e4
  )$est

# add omega to scales
well_being <- 
  well_being %>% 
  mutate(
    omega = well_being_omega
  )

### psychological needs
needs <- 
  bind_rows(
    list(
      describe(
        dat,
        "autonomy_state",
        trait = FALSE
      ),
      describe(
        dat,
        "competence_state",
        trait = FALSE
      ),
      describe(
        dat,
        "relatedness_state",
        trait = FALSE
      )
    )
  )

# get omegas
autonomy_omega <- 
  ci.reliability(
    data = dat %>% 
      select(
        autonomy_1:autonomy_4
      ),
    type = "omega",
    B = 1e4
  )$est

competence_omega <- 
  ci.reliability(
    data = dat %>% 
      select(
        competence_1:competence_4
      ),
    type = "omega",
    B = 1e4
  )$est

relatedness_omega <- 
  ci.reliability(
    data = dat %>% 
      select(
        relatedness_1:relatedness_4
      ),
    type = "omega",
    B = 1e4
  )$est

# add omegas to descriptives
needs <- 
  needs %>% 
  mutate(
    omega = c(
      autonomy_omega,
      competence_omega,
      relatedness_omega
    )
  )

### experiences
experiences <- 
  bind_rows(
    list(
      describe(
        dat,
        "satisfied",
        trait = FALSE
      ),
      describe(
        dat,
        "boring",
        trait = FALSE
      ),
      describe(
        dat,
        "stressful",
        trait = FALSE
      ),
      describe(
        dat,
        "enjoyable",
        trait = FALSE
      )
    )
  )


# bind those three and round to two decimals
state_descriptives <- 
  bind_rows(
    well_being,
    needs,
    experiences
  ) %>% 
  mutate(
    across(
      -variable,
      ~ round(.x, digits = 2)
    )
  )

knitr::kable(
  state_descriptives,
  caption = "Descriptives for state variables"
)

# clear up workspace
rm(
  well_being,
  needs,
  well_being_omega,
  autonomy_omega,
  competence_omega,
  relatedness_omega
)
```

```{r states-visualize, warning=FALSE, message=FALSE, fig.cap="Distribution of state variables", fig.dim=c(8.5,9), echo=FALSE}
plot_grid(
  # well-being
  single_cloud(
    dat,
    state_descriptives,
    "well_being_state",
    "#999999",
    title = "State well-being",
    trait = FALSE
    ),
  # needs
  single_cloud(
    dat,
    state_descriptives,
    "autonomy_state",
    "#E69F00",
    title = "Autonomy",
    trait = FALSE
  ),
  single_cloud(
    dat,
    state_descriptives,
    "competence_state",
    "#56B4E9",
    title = "Competence",
    trait = FALSE
  ),
  single_cloud(
    dat,
    state_descriptives,
    "relatedness_state",
    "#009E73",
    title = "Relatedness",
    trait = FALSE
  ),
  single_cloud(
    dat,
    experiences,
    "satisfied",
    "#F0E442",
    title = "Satisfaction",
    trait = FALSE
  ),
  single_cloud(
    dat,
    experiences,
    "boring",
    "#0072B2",
    title = "Boredom",
    trait = FALSE
  ),
  single_cloud(
    dat,
    experiences,
    "stressful",
    "#D55E00",
    title = "Stress",
    trait = FALSE
  ),
  single_cloud(
    dat,
    experiences,
    "enjoyable",
    "#CC79A7",
    title = "Enjoyment",
    trait = FALSE
  ),
  ncol = 2
)
```
In Figure \@ref(fig:visualize-correlations-objective-subjective) we see the correlations between variables on the state level.
```{r visualize-correlations-objective-subjective, message=FALSE, warning=F, echo=FALSE, fig.cap="Correlation matrix of state level variables. social = screen time on social media; _s = subjective; _o = objective; not = notifications", fig.dim=c(14,14)}
ggpairs(
  data = dat %>%
    select(
      social_media_subjective:weekly_notifications,
      well_being_state:relatedness_state
    ) %>% 
    rename( # just to make labels shorter for this figure
      social_s = social_media_subjective,
      pickups_s = pickups_subjective,
      not_s = notifications_subjective,
      social_o = social_media_objective,
      pickups_o = pickups_objective,
      not_weekly = weekly_notifications,
      well_being = well_being_state,
      autonomy = autonomy_state,
      competence = competence_state,
      relatedness = relatedness_state
    ),
  lower = list(
    continuous = lm_function # custom helper function
  ),
  diag = list(
    continuous = dens_function # custom helper function
  )
) +
  theme(
    axis.line=element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks=element_blank(),
    axis.title.y=element_blank(),
    axis.title.x=element_blank(),
    legend.position="none",
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

In Figure \@ref(fig:visualize-correlations-objective-trait) we see the correlations between use variables on the state level and the trait level.
```{r visualize-correlations-objective-trait, message=FALSE, warning=F, echo=FALSE, fig.cap="Correlation matrix of use variables (state) and personality traits. social = screen time on social media; _s = subjective; _o = objective; not = notifications; extra = extraversion; agree = agreeableness; con = conscientiousness; neuo = neuroticism; open = openness", fig.dim=c(15,15)}
ggpairs(
  data = dat %>%
    select(
      social_media_subjective:weekly_notifications,
      contains("trait"),
      extraversion:openness
    ) %>% 
    rename(
      social_s = social_media_subjective,
      pickups_s = pickups_subjective,
      not_s = notifications_subjective,
      social_o = social_media_objective,
      pickups_o = pickups_objective,
      not_weekly = weekly_notifications,
      autonomy = autonomy_trait,
      competence = competence_trait,
      relatedness = relatedness_trait,
      extra = extraversion,
      agree = agreeableness,
      con = conscientiousness,
      neuro = neuroticism,
      open = openness
      
    ),
  lower = list(
    continuous = lm_function # custom helper function
  ),
  diag = list(
    continuous = dens_function # custom helper function
  )
) +
  theme(
    axis.line=element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks=element_blank(),
    axis.title.y=element_blank(),
    axis.title.x=element_blank(),
    legend.position="none",
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    plot.background=element_blank(),
    strip.background = element_blank()
  )
```

## Plots for paper

Here, I'll create summary figures for the paper.
I'll begin with plotting the traits.

For the plot, the data need to be in the long format.
```{r data-figure1}
tmp <- 
  dat %>% 
  group_by(id) %>% 
  slice(1) %>% 
  ungroup() %>% 
  select(all_of(c("id", trait_descriptives$variable))) %>% 
  pivot_longer(
    -id,
    names_to = "variable",
    values_to = "value"
  )

rename_levels <- c(
  "Autonomy",
  "Competence",
  "Relatedness",
  "Agreeableness",
  "Conscientiousness",
  "Extraversion",
  "Neuroticism",
  "Openness"
)

my_string <- "_trait"

# reorder and rename factor levels
clean_plot_data <- 
  function(
    dat,
    levels_to_rename,
    string_to_remove
  ){
    dat <- 
      dat %>% 
      mutate(
        # in case it's social media variables
        variable = case_when(
          variable == "social_media_objective" ~ "Objective (h)",
          variable == "social_media_subjective" ~ "Subjective (h)",
          variable == "error" ~ "Accuracy (%)",
          TRUE ~ variable
        ),
        # remove _trait at the end and capitalize
        variable = str_to_sentence(str_remove(variable, string_to_remove)),
        variable = as.factor(variable),
        variable = str_replace(variable, "_", "-"),
        
        # reorder factor levels
        variable = fct_relevel(
          variable,
          levels_to_rename
        )
      )
    return(dat)
  }

tmp <- clean_plot_data(tmp, rename_levels, my_string)
trait_descriptives <- clean_plot_data(trait_descriptives, rename_levels, my_string)
```

Okay, we already have the aggregated info in `trait_descriptives`, so we can get to plotting.
```{r figure1, warning=FALSE}
# function for breaks
my_breaks <- 
  function(x) {
    if (max(x) > 5){
      1:7
    } else {
    1:5
    }
  }

# function for limits
my_limits <- 
  function(x) {
    if (max(x) > 5){
      c(1,7)
    } else {
    c(1,5)
    }
  }

# color palette (not needed anymore after review that colors made the figure harder to see)
cb_palette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# plot
ggplot(
  tmp,
  aes(
    x = value,
    y = 1
  )
) +
  geom_quasirandom(groupOnX=FALSE, size = 0.7, shape = 20, color = "black") +
  facet_wrap(
    ~ variable, 
    scales = "free_x"
  ) +
  scale_x_continuous(breaks = my_breaks, limits = my_limits) +
  geom_text(
    data = trait_descriptives,
    aes(
      x = 1.6,
      y = 1.4,
      label = paste0("M = ", mean),
      family = "Corbel"
    ),
    size = 2.5,
    color = "black"
  ) +
  geom_text(
    data = trait_descriptives,
    aes(
      x = 1.6,
      y = 1.3,
      label = paste0("SD = ", sd),
      family = "Corbel"
    ),
    size = 2.5,
    color = "black"
  ) +
  geom_text(
    data = trait_descriptives,
    aes(
      x = 1.6,
      y = 1.2,
      label = paste0("\u03a9 = ", omega),
      family = "Corbel"
    ),
    size = 2.5,
    color = "black"
  ) +
  theme_cowplot() +
  # scale_colour_manual(values=cb_palette) +
  # scale_fill_manual(values = cb_palette) +
  theme(
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank(),
    strip.background.x = element_blank(),
    strip.background.y = element_blank(),
    legend.position = "none",
    text = element_text(family = "Corbel")
  ) -> figure1

figure1

ggsave(
  here("figures", "figure1.tiff"),
  plot = figure1,
  width = 21 * 0.8,
  height = 29.7 * 0.4,
  units = "cm",
  dpi = 300
)
```

Okay, next the state variables.
```{r data-figure2}
tmp <- 
  dat %>% 
  select(all_of(c("id", state_descriptives$variable))) %>% 
  pivot_longer(
    -id,
    names_to = "variable",
    values_to = "value"
  )

rename_levels <- c(
  "Autonomy",
  "Competence",
  "Relatedness",
  "Boring",
  "Enjoyable",
  "Satisfied",
  "Stressful",
  "Well-being"
)

my_string <- "_state"

tmp <- clean_plot_data(tmp, rename_levels, my_string)
state_descriptives <- clean_plot_data(state_descriptives, rename_levels, my_string)

# position of the text (so it doesn't overlap with points)
state_descriptives <- 
  state_descriptives %>% 
  mutate(
    x_position = 1.6,
    y_position = 1.45
  )
```

Then to plotting.
```{r figure2, warning=FALSE}
# plot
ggplot(
  tmp,
  aes(
    x = value,
    y = 1
  )
) +
  geom_quasirandom(groupOnX=FALSE, size = 0.7, shape = 20, color = "black") +
  facet_wrap(
    ~ variable, 
    scales = "free_x"
  ) +
  scale_x_continuous(breaks = my_breaks, limits = my_limits) +
  geom_text(
    data = state_descriptives,
    aes(
      x = x_position,
      y = y_position + 0.1,
      label = paste0("M = ", mean),
      family = "Corbel"
    ),
    size = 2.5,
    color = "black"
  ) +
  geom_text(
    data = state_descriptives,
    aes(
      x = x_position,
      y = y_position,
      label = paste0("SD = ", sd),
      family = "Corbel"
    ),
    size = 2.5,
    color = "black"
  ) +
  geom_text(
    data = state_descriptives,
    aes(
      x = x_position,
      y = y_position - 0.1,
      label = paste0("\u03a9 = ", omega),
      family = "Corbel"
    ),
    size = 2.5,
    color = "black",
    alpha = if_else(is.na(state_descriptives$omega), 0, 1) # one-item measure don't have omega, so I make those see through
  ) +
  theme_cowplot() +
  # scale_colour_manual(values=cb_palette) +
  # scale_fill_manual(values = cb_palette) +
  theme(
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank(),
    strip.background.x = element_blank(),
    strip.background.y = element_blank(),
    legend.position = "none",
    text = element_text(family = "Corbel")
  ) -> figure2

figure2

ggsave(
  here("figures", "figure2.tiff"),
  plot = figure2,
  width = 21 * 0.8,
  height = 29.7 * 0.4,
  units = "cm",
  dpi = 300
)
```

Alright, last the smartphone use variables.
```{r data-figure3}
tmp <- 
  dat %>% 
  select(all_of(c("id", "social_media_objective", "social_media_subjective", "error"))) %>%
  # turn to hours
  mutate(
    across(
      contains("social_media"),
      ~ .x /60
    )
  ) %>% 
  pivot_longer(
    -id,
    names_to = "variable",
    values_to = "value"
  )

rename_levels <- c(
  "Objective (h)",
  "Subjective (h)",
  "Accuracy (%)"
)

my_string <- "_state"

tmp <- clean_plot_data(tmp, rename_levels, my_string)
social_media2 <- clean_plot_data(social_media, rename_levels, my_string) %>% 
  filter(variable %in% c("Objective (h)", "Subjective (h)", "Accuracy (%)")) %>% 
  # add x axis position for geom_text
  mutate(
    x_position = case_when(
      variable == "Accuracy (%)" ~ 1200*0.8,
      TRUE ~ 0.8*13
    )
  )
```

And the plot.
```{r figure3, warning=FALSE}
# function for breaks
my_breaks <- 
  function(x) {
    if (max(x) < 100){
      seq(0, 13, 2)
    } else {
    c(-200, 0, 400, 800, 1200)
    }
  }

# function for limits
my_limits <- 
  function(x) {
    if (max(x) < 100){
      c(0, 13)
    } else {
    c(-200, 1200)
    }
  }

# plot
ggplot(
  tmp,
  aes(
    x = value,
    y = 1
  )
) +
  geom_quasirandom(groupOnX=FALSE, size = 0.7, shape = 20, color = "black") +
  facet_wrap(
    ~ variable, 
    scales = "free_x"
  ) +
  scale_x_continuous(breaks = my_breaks, limits = my_limits) +
  geom_text(
    data = social_media2,
    aes(
      x = x_position,
      y = 0.7,
      label = paste0("M = ", mean),
      family = "Corbel"
    ),
    size = 3,
    color = "black"
  ) +
  geom_text(
    data = social_media2,
    aes(
      x = x_position,
      y = 0.67,
      label = paste0("SD = ", sd),
      family = "Corbel"
    ),
    size = 3,
    color = "black"
  ) +
  theme_cowplot() +
  scale_colour_manual(values=cb_palette) +
  scale_fill_manual(values = cb_palette) +
  theme(
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank(),
    strip.background.x = element_blank(),
    strip.background.y = element_blank(),
    legend.position = "none",
    text = element_text(family = "Corbel")
  ) -> figure3

figure3

ggsave(
  here("figures", "figure3.tiff"),
  plot = figure3,
  width = 21 * 0.8,
  height = 29.7 * 0.4,
  units = "cm",
  dpi = 300
)
```
